<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚†ã‚‹ã‚‹ãƒãƒ£ãƒƒãƒˆ</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    body { font-family: sans-serif; padding: 12px; }
    input { width: 260px; padding: 6px; margin: 4px 0; }
    button { padding: 6px 10px; margin: 4px 2px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .card { border: 1px solid #ccc; background: #fafafa; padding: 10px; border-radius: 10px; margin: 10px 0; }
    .row { display:flex; gap:8px; flex-wrap: wrap; align-items: center; }

    #roomsBox {
      border: 1px solid #ccc; width: 260px; height: 180px;
      overflow: auto; padding: 6px; margin: 10px 0; background: #fafafa;
    }
    .roomRow { display: flex; gap: 6px; margin: 3px 0; align-items: center; }
    .roomBtn {
      flex: 1; width: auto; text-align: left; padding: 6px;
      cursor: pointer; border: 1px solid #ddd; background: #fff;
    }
    .roomBtn:hover { background: #f0f0f0; }

    .delBtn { width: 44px; padding: 6px; border: 1px solid #ddd; background: #fff; cursor: pointer; }
    .delBtn:hover { background: #ffecec; }
    .delBtn:disabled { opacity: .35; cursor: not-allowed; background: #fff; }

    #status { font-size: 12px; color: #666; margin-top: 6px; }
    .ok { color: #0a7; }
    .ng { color: #c33; }
    .sys { color: #666; font-size: 12px; margin: 4px 0; }

    .layout {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 12px;
      align-items: start;
    }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    #callBox{
      border: 1px solid #ccc;
      padding: 10px;
      background: #fafafa;
    }
    #callState { font-size: 12px; color:#444; margin-top: 6px; }

    #peopleBox {
      border: 1px solid #ccc;
      padding: 10px;
      background: #fff;
      margin-top: 10px;
    }
    #peopleList { margin-top: 8px; }
    .personRow{
      display:flex;
      justify-content: space-between;
      gap: 8px;
      padding: 6px;
      border: 1px solid #eee;
      margin: 6px 0;
      border-radius: 6px;
      background:#fafafa;
      font-size: 14px;
    }
    .pill {
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #ddd;
      background: #fff;
      color:#333;
      white-space: nowrap;
    }

    #chat {
      border: 1px solid #ccc;
      height: 360px;
      overflow: auto;
      padding: 8px;
      background: #fff;
      width: min(900px, 95vw);
    }

    .hint {
      font-size: 12px;
      color:#666;
      margin-top: 6px;
      line-height: 1.4;
    }

    details { margin-top: 10px; }
    #log {
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      border: 1px solid #ddd;
      background: #fff;
      padding: 8px;
      border-radius: 8px;
      max-height: 180px;
      overflow: auto;
    }

    .roomBtn.calling {
      border-color: #8be3c8;
      background: #f1fffb;
    }
    .callMark {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #0a7;
      font-weight: 700;
      margin-right: 6px;
    }
  </style>
</head>

<body>
  <h2>ã‚†ã‚‹ã‚‹ãƒãƒ£ãƒƒãƒˆ</h2>

  <!-- â˜…ãƒ­ã‚°ã‚¤ãƒ³ã‚«ãƒ¼ãƒ‰ -->
  <div class="card">
    <b>ğŸ” ãƒ­ã‚°ã‚¤ãƒ³</b>
    <div class="hint">â€»ãƒ­ã‚°ã‚¤ãƒ³ã—ãªã„ã¨ä½¿ãˆã¾ã›ã‚“ï¼ˆRLSã§ä¿è­·ï¼‰</div>

    <div class="row" style="margin-top:8px;">
      <input id="email" placeholder="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹" style="width:260px;" />
      <input id="pass" type="password" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰" style="width:260px;" />
    </div>
    <div class="row">
      <button onclick="signUp()">æ–°è¦ç™»éŒ²</button>
      <button onclick="signIn()">ãƒ­ã‚°ã‚¤ãƒ³</button>
      <button onclick="signOut()" id="signOutBtn" disabled>ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <input id="displayName" placeholder="è¡¨ç¤ºåï¼ˆãƒãƒ£ãƒƒãƒˆåï¼‰" style="width:260px;" />
      <button onclick="saveDisplayName()" id="saveNameBtn" disabled>è¡¨ç¤ºåä¿å­˜</button>
    </div>

    <div class="hint" id="authState">æœªãƒ­ã‚°ã‚¤ãƒ³</div>
  </div>

  <div>
    <input id="name" placeholder="åå‰ï¼ˆè‡ªå‹•ï¼‰" disabled /><br />
    <input id="room" placeholder="éƒ¨å±‹åï¼ˆä¾‹: testï¼‰" /><br />

    <button onclick="createRoom()" id="createRoomBtn" disabled>éƒ¨å±‹ä½œæˆ</button>
    <button onclick="join()" id="joinBtn" disabled>å…¥å®¤</button>
    <button onclick="leave()" id="leaveBtn" disabled>é€€å®¤</button>
    <button onclick="loadRooms()" id="reloadRoomsBtn" disabled>éƒ¨å±‹ä¸€è¦§æ›´æ–°</button>

    <div style="margin-top:10px;">
      <b>éƒ¨å±‹ä¸€è¦§ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰</b>
      <div id="roomsBox"></div>
      <div class="hint" id="roomHint">
        ãƒ»éƒ¨å±‹åã‚¯ãƒªãƒƒã‚¯ï¼šå…¥åŠ›æ¬„ã¸ / ãƒ»éƒ¨å±‹åãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šãã®éƒ¨å±‹ã«å…¥å®¤<br />
        ãƒ»ğŸ—‘ï¼šéƒ¨å±‹å‰Šé™¤ï¼ˆâ€»ãã®éƒ¨å±‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚å‰Šé™¤ï¼‰<br />
        ãƒ»é€šè©±ã¯ã€Œå…¥å®¤ã€ã—ã¦ã‹ã‚‰ã€Œé€šè©±ã«å‚åŠ ï¼ˆé–‹å§‹ï¼‰ã€ã‚’æŠ¼ã—ã¦ã­
      </div>

      <details>
        <summary>ğŸ”§ ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆå›°ã£ãŸã‚‰ã“ã“ã‚’ã‚³ãƒ”ãƒšã—ã¦é€ã£ã¦ï¼‰</summary>
        <div id="log"></div>
      </details>
    </div>
  </div>

  <hr />

  <div id="status"></div>

  <div class="layout">
    <div>
      <div id="callBox">
        <b>ğŸ¤ éŸ³å£°é€šè©±ï¼ˆè¤‡æ•°äººï¼‰</b>
        <div style="margin-top:8px;">
          <button onclick="startVoice()" id="startVoiceBtn" disabled>é€šè©±ã«å‚åŠ ï¼ˆé–‹å§‹ï¼‰</button>
          <button onclick="toggleMute()" id="muteBtn" disabled>ãƒŸãƒ¥ãƒ¼ãƒˆ: OFF</button>
          <button onclick="hangupAll()" id="hangupBtn" disabled>é€šè©±é€€å‡º</button>
        </div>
        <div id="callState">æœªæ¥ç¶šï¼ˆå…¥å®¤ã—ã¦ã‹ã‚‰ä½¿ã£ã¦ã­ï¼‰</div>
        <div id="audios" style="margin-top:8px;"></div>
      </div>

      <div id="peopleBox">
        <b>ğŸ‘¥ å‚åŠ è€…ï¼ˆé€šè©±ãƒãƒ£ãƒ³ãƒãƒ«ï¼‰</b>
        <div class="hint">â€»ã€Œé€šè©±ã«å‚åŠ ã€ã‚’æŠ¼ã—ãŸäººãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆ</div>
        <div id="peopleList"></div>
      </div>
    </div>

    <div>
      <div id="chat"></div>
      <div style="margin-top:8px;">
        <input id="msg" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸" disabled />
        <button onclick="send()" id="sendBtn" disabled>é€ä¿¡</button>
      </div>
    </div>
  </div>

<script>
/* =================== Supabase è¨­å®š =================== */
const SUPABASE_URL = "https://gqqkjytefyllfomtqcqd.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdxcWtqeXRlZnlsbGZvbXRxY3FkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4NDM2NDAsImV4cCI6MjA4MjQxOTY0MH0.ve2TXRWgqGK_KT1i_ZjvCBf6wOxNjp127xeQgC3tjWM";

const sb = supabase.createClient(
  SUPABASE_URL.trim(),
  (SUPABASE_KEY || "").replace(/\s+/g, "")
);

/* =================== çŠ¶æ…‹ =================== */
let room = "";
let name = "";
let authUser = null;

let roomsChannel = null;
let messagesChannel = null;
const SYSTEM_NAME = "__system__";

let inCall = false;

/* â˜…é€šè©±ä¸­ã®éƒ¨å±‹æ¤œå‡ºï¼ˆcall_participants.updated_at ãŒæ–°ã—ã„éƒ¨å±‹ã ã‘ğŸ“ï¼‰ */
let activeCallRooms = new Set();
/* â˜…RLSå´ã® interval '30 seconds' ã¨åˆã‚ã›ã‚‹ */
const CALL_ALIVE_SEC = 30;

/* =================== ãƒ­ã‚° =================== */
function log(...args){
  const s = args.map(a => (typeof a === "string" ? a : JSON.stringify(a, null, 2))).join(" ");
  console.log("[yururu]", ...args);
  const el = document.getElementById("log");
  if (!el) return;
  el.textContent += s + "\n";
  el.scrollTop = el.scrollHeight;
}
window.addEventListener("error", (e)=>log("JS ERROR:", e.message));
window.addEventListener("unhandledrejection", (e)=>log("PROMISE ERROR:", e.reason));

/* =================== è¡¨ç¤ºç³» =================== */
function setStatus(text, ok = true) {
  const el = document.getElementById("status");
  el.innerHTML = `<span class="${ok ? "ok" : "ng"}">${text}</span>`;
}
function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

/* =================== Auth =================== */
function setAuthUI() {
  const loggedIn = !!authUser;
  document.getElementById("signOutBtn").disabled = !loggedIn;
  document.getElementById("saveNameBtn").disabled = !loggedIn;

  document.getElementById("createRoomBtn").disabled = !loggedIn;
  document.getElementById("joinBtn").disabled = !loggedIn;
  document.getElementById("reloadRoomsBtn").disabled = !loggedIn;

  document.getElementById("leaveBtn").disabled = !loggedIn;
  document.getElementById("sendBtn").disabled = !loggedIn;
  document.getElementById("msg").disabled = !loggedIn;

  document.getElementById("name").disabled = true; // è‡ªå‹•
}

function setAuthStateText() {
  const el = document.getElementById("authState");
  if (!authUser) {
    el.textContent = "æœªãƒ­ã‚°ã‚¤ãƒ³";
    return;
  }
  const dn = (authUser.user_metadata && authUser.user_metadata.display_name) || "";
  el.textContent = `ãƒ­ã‚°ã‚¤ãƒ³ä¸­: ${authUser.email}${dn ? " / è¡¨ç¤ºå: " + dn : ""}`;
}

async function reloadSession() {
  const { data, error } = await sb.auth.getSession();
  if (error) log("getSession error", error);

  authUser = data?.session?.user || null;
  name = (authUser?.user_metadata?.display_name || "").trim();

  if (authUser && !name) {
    // è¡¨ç¤ºåãŒç„¡ã„ãªã‚‰ email ã®å‰åŠã‚’ä»®åã«
    name = (authUser.email || "user").split("@")[0];
  }
  document.getElementById("name").value = name || "";
  document.getElementById("displayName").value = (authUser?.user_metadata?.display_name || "");

  setAuthUI();
  setAuthStateText();
}

async function signUp() {
  const email = document.getElementById("email").value.trim();
  const pass = document.getElementById("pass").value.trim();
  if (!email || !pass) return alert("ãƒ¡ãƒ¼ãƒ«ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥ã‚Œã¦ã­ï¼");

  const { error } = await sb.auth.signUp({ email, password: pass });
  if (error) {
    log("signUp error", error);
    alert("æ–°è¦ç™»éŒ²å¤±æ•—: " + error.message);
    return;
  }
  alert("æ–°è¦ç™»éŒ²OKï¼ãƒ¡ãƒ¼ãƒ«ç¢ºèªãŒå¿…è¦ãªè¨­å®šã®å ´åˆã¯ãƒ¡ãƒ¼ãƒ«ã‚‚è¦‹ã¦ã­ï¼");
  await reloadSession();
  await loadRooms();
}

async function signIn() {
  const email = document.getElementById("email").value.trim();
  const pass = document.getElementById("pass").value.trim();
  if (!email || !pass) return alert("ãƒ¡ãƒ¼ãƒ«ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥ã‚Œã¦ã­ï¼");

  const { error } = await sb.auth.signInWithPassword({ email, password: pass });
  if (error) {
    log("signIn error", error);
    alert("ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—: " + error.message);
    return;
  }
  alert("ãƒ­ã‚°ã‚¤ãƒ³OKï¼");
  await reloadSession();
  await loadRooms();
  await startRealtime();
}

async function signOut() {
  await hangupAll();
  room = "";
  document.getElementById("chat").innerHTML = "";
  renderPeople([]);

  const { error } = await sb.auth.signOut();
  if (error) log("signOut error", error);

  authUser = null;
  name = "";
  document.getElementById("name").value = "";

  setAuthUI();
  setAuthStateText();
  setStatus("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ");
}

async function saveDisplayName() {
  if (!authUser) return alert("å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­ï¼");
  const dn = document.getElementById("displayName").value.trim();
  if (!dn) return alert("è¡¨ç¤ºåã‚’å…¥ã‚Œã¦ã­ï¼");

  const { error } = await sb.auth.updateUser({
    data: { display_name: dn }
  });
  if (error) {
    log("updateUser error", error);
    alert("è¡¨ç¤ºåä¿å­˜å¤±æ•—: " + error.message);
    return;
  }
  alert("è¡¨ç¤ºåä¿å­˜OKï¼");
  await reloadSession();
}

/* =================== ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒƒã‚» =================== */
async function sendSystem(text) {
  if (!room) return;
  if (!authUser) return;

  const { error } = await sb.from("messages").insert({
    room_id: room,
    user_id: authUser.id,
    name: SYSTEM_NAME,
    message: text
  });
  if (error) log("sendSystem error", error);
}

/* =================== é€šè©±ä¸­éƒ¨å±‹ä¸€è¦§ã®æ›´æ–° =================== */
async function refreshActiveCallRooms() {
  if (!authUser) return;

  const since = new Date(Date.now() - CALL_ALIVE_SEC * 1000).toISOString();
  const { data, error } = await sb
    .from("call_participants")
    .select("room_id, updated_at")
    .gte("updated_at", since);

  if (error) {
    log("refreshActiveCallRooms error", error);
    activeCallRooms = null;
    setStatus("é€šè©±çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—ï¼ˆå®‰å…¨ã®ãŸã‚å‰Šé™¤ãƒ­ãƒƒã‚¯ï¼‰: " + error.message, false);
    updateRoomDeleteButtons();
    return;
  }

  const s = new Set();
  (data || []).forEach(r => s.add(r.room_id));
  activeCallRooms = s;
  updateRoomDeleteButtons();
}

/* =================== UIçŠ¶æ…‹æ›´æ–° =================== */
function setButtonsState() {
  const joined = !!(room && name && authUser);

  document.getElementById("startVoiceBtn").disabled = !joined;
  document.getElementById("hangupBtn").disabled = !joined;
  document.getElementById("muteBtn").disabled = !(joined && localStream);

  document.getElementById("leaveBtn").disabled = !authUser;
  document.getElementById("sendBtn").disabled = !authUser;
  document.getElementById("msg").disabled = !authUser;

  updateRoomDeleteButtons();
  updateRoomHint();
}

function updateRoomHint(){
  const el = document.getElementById("roomHint");
  if (!el) return;

  if (!authUser) {
    el.innerHTML = "ğŸ” ã¾ãšãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­";
    return;
  }

  if (activeCallRooms === null) {
    el.innerHTML =
      "âš ï¸ é€šè©±çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—ä¸­ï¼šå®‰å…¨ã®ãŸã‚éƒ¨å±‹å‰Šé™¤ã¯ãƒ­ãƒƒã‚¯ä¸­<br />" +
      "ãƒ»RLSãƒãƒªã‚·ãƒ¼ / ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹æˆã‚’ç¢ºèªã—ã¦ã­";
    return;
  }

  if (inCall) {
    el.innerHTML =
      "âœ… ã‚ãªãŸã¯é€šè©±ä¸­ï¼šéƒ¨å±‹å‰Šé™¤ã¯ãƒ­ãƒƒã‚¯ä¸­ï¼ˆå…ˆã«ã€Œé€šè©±é€€å‡ºã€ã—ã¦ã­ï¼‰<br />" +
      "ãƒ»éƒ¨å±‹åã‚¯ãƒªãƒƒã‚¯ï¼šå…¥åŠ›æ¬„ã¸ / ãƒ»éƒ¨å±‹åãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šãã®éƒ¨å±‹ã«å…¥å®¤<br />" +
      "ãƒ»ğŸ—‘ï¼šé€šè©±ä¸­ã®éƒ¨å±‹ã¯å‰Šé™¤ã§ããªã„ï¼ˆèª°ã‹ãŒé€šè©±ã—ã¦ãŸã‚‰NGï¼‰";
  } else {
    el.innerHTML =
      "ãƒ»éƒ¨å±‹åã‚¯ãƒªãƒƒã‚¯ï¼šå…¥åŠ›æ¬„ã¸ / ãƒ»éƒ¨å±‹åãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šãã®éƒ¨å±‹ã«å…¥å®¤<br />" +
      "ãƒ»ğŸ—‘ï¼šé€šè©±ä¸­ã®éƒ¨å±‹ã¯å‰Šé™¤ã§ããªã„ï¼ˆèª°ã‹ãŒé€šè©±ã—ã¦ãŸã‚‰NGï¼‰<br />" +
      "ãƒ»é€šè©±ã¯ã€Œå…¥å®¤ã€ã—ã¦ã‹ã‚‰ã€Œé€šè©±ã«å‚åŠ ï¼ˆé–‹å§‹ï¼‰ã€ã‚’æŠ¼ã—ã¦ã­";
  }
}

function isRoomLocked(rn){
  if (activeCallRooms === null) return true;
  return inCall || activeCallRooms.has(rn);
}

function updateRoomDeleteButtons(){
  const box = document.getElementById("roomsBox");
  if (!box) return;

  const rows = box.querySelectorAll(".roomRow");
  rows.forEach(row => {
    const btn = row.querySelector("button.roomBtn");
    const del = row.querySelector("button.delBtn");
    if (!btn || !del) return;

    const rn = btn.dataset.room || btn.textContent;
    const locked = !authUser ? true : isRoomLocked(rn);

    del.disabled = locked;
    del.title = locked
      ? (!authUser ? "ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­"
         : activeCallRooms === null ? "é€šè©±çŠ¶æ…‹ã®å–å¾—å¤±æ•—ä¸­ï¼ˆå®‰å…¨ãƒ­ãƒƒã‚¯ï¼‰"
         : inCall ? "ã‚ãªãŸãŒé€šè©±ä¸­ãªã®ã§å‰Šé™¤ã§ãã¾ã›ã‚“ï¼ˆé€šè©±é€€å‡ºã—ã¦ã­ï¼‰"
         : "ã“ã®éƒ¨å±‹ã¯èª°ã‹ãŒé€šè©±ä¸­ãªã®ã§å‰Šé™¤ã§ãã¾ã›ã‚“")
      : "éƒ¨å±‹å‰Šé™¤";

    const calling = (activeCallRooms instanceof Set) && activeCallRooms.has(rn);
    btn.classList.toggle("calling", calling);
  });
}

/* =================== Realtimeï¼ˆéƒ¨å±‹/ãƒ¡ãƒƒã‚»ï¼‰ =================== */
async function startRealtime() {
  if (!authUser) return;
  if (roomsChannel || messagesChannel) return;

  roomsChannel = sb
    .channel("rooms-ch")
    .on("postgres_changes", { event: "*", schema: "public", table: "rooms" }, async () => {
      await loadRooms();
    })
    .subscribe();

  messagesChannel = sb
    .channel("messages-ch")
    .on("postgres_changes", { event: "*", schema: "public", table: "messages" }, async (payload) => {
      if (!room) return;
      const newRow = payload.new || {};
      const oldRow = payload.old || {};
      const rid = newRow.room_id || oldRow.room_id;
      if (rid === room) await loadMessages();
    })
    .subscribe();

  setStatus("ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¥ç¶šOK");
}

/* =================== éƒ¨å±‹ä¸€è¦§ =================== */
async function loadRooms() {
  if (!authUser) {
    document.getElementById("roomsBox").innerHTML = "<div>ğŸ” ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­</div>";
    return;
  }

  await refreshActiveCallRooms();

  let res = await sb.from("rooms")
    .select("room_name, created_at")
    .order("created_at", { ascending: true });

  if (res.error && String(res.error.message || "").includes("created_at")) {
    res = await sb.from("rooms").select("room_name");
  }

  const { data, error } = res;
  if (error) { log("loadRooms error", error); setStatus("éƒ¨å±‹ä¸€è¦§å–å¾—å¤±æ•—: " + error.message, false); return; }

  const box = document.getElementById("roomsBox");
  box.innerHTML = "";

  if (!data || data.length === 0) {
    box.innerHTML = "<div>ã¾ã éƒ¨å±‹ãŒãªã„ã‚ˆï¼ˆéƒ¨å±‹ä½œæˆã—ã¦ã­ï¼‰</div>";
    if (!room) setStatus("éƒ¨å±‹ãªã—ï¼ˆæ–°ã—ãä½œã£ã¦OKï¼‰");
    return;
  }

  data.forEach(r => {
    const rowEl = document.createElement("div");
    rowEl.className = "roomRow";

    const btn = document.createElement("button");
    btn.className = "roomBtn";

    const rn = r.room_name;
    btn.dataset.room = rn;

    const calling = (activeCallRooms instanceof Set) && activeCallRooms.has(rn);
    if (calling) {
      btn.innerHTML = `<span class="callMark">ğŸ“</span>${escapeHtml(rn)}`;
      btn.classList.add("calling");
    } else {
      btn.textContent = rn;
      btn.classList.remove("calling");
    }

    btn.onclick = () => { document.getElementById("room").value = rn; };
    btn.ondblclick = async () => { document.getElementById("room").value = rn; await join(); };

    const del = document.createElement("button");
    del.className = "delBtn";
    del.textContent = "ğŸ—‘";
    del.disabled = isRoomLocked(rn);

    del.onclick = async () => {
      await refreshActiveCallRooms();
      if (isRoomLocked(rn)) {
        alert(activeCallRooms === null
          ? "é€šè©±çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—ä¸­ã®ãŸã‚ã€å®‰å…¨ã®ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚"
          : inCall
          ? "ã‚ãªãŸãŒé€šè©±ä¸­ã¯éƒ¨å±‹ã‚’å‰Šé™¤ã§ãã¾ã›ã‚“ï¼\nå…ˆã«ã€Œé€šè©±é€€å‡ºã€ã‚’æŠ¼ã—ã¦ã­ã€‚"
          : "ã“ã®éƒ¨å±‹ã¯èª°ã‹ãŒé€šè©±ä¸­ãªã®ã§å‰Šé™¤ã§ãã¾ã›ã‚“ï¼");
        return;
      }
      if (!confirm(`éƒ¨å±‹ã€Œ${rn}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nâ€»ãã®éƒ¨å±‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚æ¶ˆãˆã¾ã™`)) return;
      await deleteRoom(rn);
    };

    rowEl.appendChild(btn);
    rowEl.appendChild(del);
    box.appendChild(rowEl);
  });

  if (!room) setStatus(`éƒ¨å±‹ä¸€è¦§OKï¼ˆ${data.length}ä»¶ï¼‰`);
  updateRoomDeleteButtons();
}

/* =================== éƒ¨å±‹ä½œæˆ =================== */
async function createRoom() {
  if (!authUser) return alert("å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­ï¼");
  const roomName = document.getElementById("room").value.trim();
  if (!roomName) return alert("éƒ¨å±‹åã‚’å…¥ã‚Œã¦ã­ï¼");

  const { data: exists, error: e1 } = await sb
    .from("rooms").select("room_name").eq("room_name", roomName).maybeSingle();

  if (e1) { log("createRoom check error", e1); alert("éƒ¨å±‹ç¢ºèªå¤±æ•—: " + e1.message); return; }
  if (exists) { alert("ãã®éƒ¨å±‹ã¯ã‚‚ã†ã‚ã‚‹ã‚ˆï¼ä¸€è¦§ã‹ã‚‰é¸ã‚“ã§å…¥å®¤ã—ã¦ã­ï¼"); return; }

  const { error } = await sb.from("rooms").insert({
    room_name: roomName,
    owner_id: authUser.id
  });
  if (error) { log("createRoom insert error", error); alert("éƒ¨å±‹ä½œæˆå¤±æ•—: " + error.message); return; }

  alert(`éƒ¨å±‹ã€Œ${roomName}ã€ã‚’ä½œã£ãŸï¼`);
  await loadRooms();
}

/* =================== ãƒ¡ãƒƒã‚»èª­ã¿è¾¼ã¿ =================== */
async function loadMessages() {
  if (!room || !authUser) return;

  let res = await sb.from("messages")
    .select("*")
    .eq("room_id", room)
    .order("created_at", { ascending: true })
    .limit(200);

  if (res.error && String(res.error.message || "").includes("created_at")) {
    res = await sb.from("messages").select("*").eq("room_id", room).limit(200);
  }

  const { data, error } = res;
  if (error) { log("loadMessages error", error); setStatus("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å–å¾—å¤±æ•—: " + error.message, false); return; }

  const chat = document.getElementById("chat");
  chat.innerHTML = "";

  (data || []).forEach(m => {
    const n = escapeHtml(m.name ?? "");
    const msg = escapeHtml(m.message ?? "");
    if (m.name === SYSTEM_NAME) chat.innerHTML += `<div class="sys">âœ… ${msg}</div>`;
    else chat.innerHTML += `<div><b>${n}:</b> ${msg}</div>`;
  });

  chat.scrollTop = chat.scrollHeight;
  setStatus(`å…¥å®¤ä¸­: ${room}ï¼ˆ${(data || []).length}ä»¶è¡¨ç¤ºï¼‰`);
}

/* =================== å…¥é€€å®¤ =================== */
async function join() {
  if (!authUser) return alert("å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­ï¼");
  const inputRoom = document.getElementById("room").value.trim();
  if (!inputRoom) { alert("éƒ¨å±‹åã‚’å…¥ã‚Œã¦ã­ï¼"); return; }

  // name ã¯ãƒ­ã‚°ã‚¤ãƒ³ç”±æ¥
  if (!name) {
    name = (authUser.email || "user").split("@")[0];
    document.getElementById("name").value = name;
  }

  const { data: exists, error } = await sb
    .from("rooms").select("room_name").eq("room_name", inputRoom).maybeSingle();

  if (error) { log("join check error", error); alert("éƒ¨å±‹ç¢ºèªå¤±æ•—: " + error.message); return; }
  if (!exists) { alert("ãã®éƒ¨å±‹ã¯ã¾ã ä½œã‚‰ã‚Œã¦ãªã„ï¼å…ˆã«ã€éƒ¨å±‹ä½œæˆã€ã—ã¦ã­ï¼"); return; }

  room = inputRoom;

  await loadMessages();
  await sendSystem(`${name} ãŒã€Œ${room}ã€ã«å…¥å®¤ã—ã¾ã—ãŸ`);

  setCallState("æœªæ¥ç¶šï¼ˆé€šè©±ã«å‚åŠ ã‚’æŠ¼ã™ã¨ä¸€è¦§ã«å‡ºã‚‹ï¼‰");
  setButtonsState();
  await loadRooms();
}

async function leave() {
  if (!room || !authUser) { alert("ã¾ã å…¥å®¤ã—ã¦ãªã„ã‚ˆï¼"); return; }

  const leavingRoom = room;
  const leavingName = name;

  await sendSystem(`${leavingName} ãŒã€Œ${leavingRoom}ã€ã‹ã‚‰é€€å®¤ã—ã¾ã—ãŸ`);

  await hangupAll();

  room = "";
  document.getElementById("chat").innerHTML = "";
  setStatus("é€€å®¤ã—ã¾ã—ãŸ");
  renderPeople([]);
  setCallState("æœªæ¥ç¶šï¼ˆå…¥å®¤ã—ã¦ã‹ã‚‰ä½¿ã£ã¦ã­ï¼‰");
  setButtonsState();
  await loadRooms();
}

/* =================== é€ä¿¡ =================== */
async function send() {
  if (!authUser) return alert("å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­ï¼");
  const text = document.getElementById("msg").value.trim();
  document.getElementById("msg").value = "";

  if (!room) { alert("å…ˆã«å…¥å®¤ã—ã¦ã­ï¼"); return; }
  if (!text) return;

  const { error } = await sb.from("messages").insert({
    room_id: room,
    user_id: authUser.id,
    name: name,
    message: text
  });

  if (error) { log("send error", error); alert("é€ä¿¡å¤±æ•—: " + error.message); return; }
  await loadMessages();
}

/* =================== éƒ¨å±‹å‰Šé™¤ =================== */
async function deleteRoom(roomName) {
  if (!authUser) return alert("å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­ï¼");
  await refreshActiveCallRooms();
  if (isRoomLocked(roomName)) {
    alert(activeCallRooms === null
      ? "é€šè©±çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—ä¸­ã®ãŸã‚ã€å®‰å…¨ã®ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚"
      : inCall
      ? "ã‚ãªãŸãŒé€šè©±ä¸­ã¯éƒ¨å±‹ã‚’å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚\nå…ˆã«ã€Œé€šè©±é€€å‡ºã€ã‚’æŠ¼ã—ã¦ã­ã€‚"
      : "ã“ã®éƒ¨å±‹ã¯èª°ã‹ãŒé€šè©±ä¸­ãªã®ã§å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚");
    return;
  }

  if (room === roomName) {
    await sendSystem(`${name} ãŒã€Œ${roomName}ã€ã‚’å‰Šé™¤ã—ã¾ã™`);
    await hangupAll();
    room = "";
    document.getElementById("chat").innerHTML = "";
    setStatus("éƒ¨å±‹ã‹ã‚‰é€€å‡ºã—ã¾ã—ãŸï¼ˆå‰Šé™¤å‡¦ç†ä¸­â€¦ï¼‰");
    setButtonsState();
  }

  const r1 = await sb.from("messages").delete().eq("room_id", roomName);
  if (r1.error) { log("delete messages error", r1.error); alert("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤å¤±æ•—: " + r1.error.message); return; }

  const r2 = await sb.from("rooms").delete().eq("room_name", roomName);
  if (r2.error) {
    log("delete room error", r2.error);
    alert("éƒ¨å±‹å‰Šé™¤å¤±æ•—: " + r2.error.message);
    return;
  }

  alert(`éƒ¨å±‹ã€Œ${roomName}ã€ã‚’å‰Šé™¤ã—ãŸã‚ˆï¼`);
  await loadRooms();
}

/* =================== Enterã§é€ä¿¡ =================== */
document.getElementById("msg").addEventListener("keydown", (e) => {
  if (e.key === "Enter") send();
});

/* =========================================================
   ğŸ¤ è¤‡æ•°äººé€šè©±ï¼ˆWebRTC Meshï¼‰+ ãƒŸãƒ¥ãƒ¼ãƒˆ + å‚åŠ è€…ä¸€è¦§ï¼ˆPresenceï¼‰
   + call_participants ã§éƒ¨å±‹å‰Šé™¤ãƒ­ãƒƒã‚¯
   ========================================================= */

/* â˜…myId ã¯ auth.uid()ï¼ˆ= authUser.idï¼‰ã‚’ä½¿ã† */
function myUid() {
  return authUser?.id || null;
}

let callChannel = null;
let localStream = null;
let micMuted = false;

const pcs = new Map();
const audios = new Map();
let people = new Map();
const remoteMute = new Map();

let callHeartbeatTimer = null;

/* =================== é€€å‡ºå‡¦ç†ï¼ˆDBã‹ã‚‰æ¶ˆã™ï¼‰ =================== */
async function safeCallLeave(reason = "") {
  try {
    if (!authUser) return;
    if (!room) return;

    stopHeartbeat();

    const uid = myUid();
    if (!uid) return;

    const { error } = await sb
      .from("call_participants")
      .delete()
      .eq("room_id", room)
      .eq("user_id", uid);

    if (error) log("safeCallLeave delete error", reason, error);
    else log("safeCallLeave ok", reason);
  } catch (e) {
    log("safeCallLeave exception", reason, e);
  }
}

/* å‚åŠ è€…UI */
function setCallState(text) {
  document.getElementById("callState").textContent = text;
}
function updateMuteBtn() {
  document.getElementById("muteBtn").textContent = "ãƒŸãƒ¥ãƒ¼ãƒˆ: " + (micMuted ? "ON" : "OFF");
  document.getElementById("muteBtn").disabled = !localStream;
}
function renderPeopleFromState() {
  const arr = [];
  for (const [pid, info] of people.entries()) {
    arr.push({
      id: pid,
      name: info?.name || pid,
      muted: (pid === myUid()) ? micMuted : (remoteMute.get(pid) || false)
    });
  }
  renderPeople(arr);
}
function renderPeople(list) {
  const box = document.getElementById("peopleList");
  box.innerHTML = "";

  if (!list || list.length === 0) {
    box.innerHTML = `<div class="hint">ã¾ã èª°ã‚‚é€šè©±ã«å‚åŠ ã—ã¦ãªã„ã‚ˆ</div>`;
    return;
  }

  list
    .sort((a,b)=> (a.name||"").localeCompare(b.name||""))
    .forEach(p => {
      const row = document.createElement("div");
      row.className = "personRow";
      const left = document.createElement("div");
      left.textContent = p.name + (p.id === myUid() ? "ï¼ˆè‡ªåˆ†ï¼‰" : "");
      const right = document.createElement("div");

      const pill1 = document.createElement("span");
      pill1.className = "pill";
      pill1.textContent = p.muted ? "ğŸ”‡ ãƒŸãƒ¥ãƒ¼ãƒˆ" : "ğŸ™ï¸ ç™ºè©±OK";

      const pill2 = document.createElement("span");
      pill2.className = "pill";
      pill2.textContent = pcs.has(p.id) ? "ğŸŸ¢ æ¥ç¶š" : (p.id === myUid() ? "ğŸŸ¦ å‚åŠ ä¸­" : "ğŸŸ¡ æœªæ¥ç¶š");

      right.appendChild(pill1);
      right.appendChild(pill2);

      row.appendChild(left);
      row.appendChild(right);
      box.appendChild(row);
    });
}

/* DB: é€šè©±å‚åŠ ç™»éŒ²/æ›´æ–° */
async function upsertCallParticipant() {
  if (!authUser) return;
  if (!room || !name) return;

  const payload = {
    room_id: room,
    user_id: myUid(),
    name,
    updated_at: new Date().toISOString()
  };
  const { error } = await sb.from("call_participants").upsert(payload);
  if (error) log("upsertCallParticipant error", error);
}

function startHeartbeat() {
  stopHeartbeat();
  callHeartbeatTimer = setInterval(async () => {
    if (!inCall) return;
    await upsertCallParticipant();
    await refreshActiveCallRooms();
  }, 15000);
}
function stopHeartbeat() {
  if (callHeartbeatTimer) clearInterval(callHeartbeatTimer);
  callHeartbeatTimer = null;
}

function shouldOfferTo(peerId) {
  return String(myUid()) < String(peerId);
}

function makePeerConnection(peerId) {
  const pc = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  });

  pc.onicecandidate = (ev) => {
    if (ev.candidate) sendSignal(peerId, { kind: "ice", candidate: ev.candidate });
  };

  pc.ontrack = (ev) => {
    let audio = audios.get(peerId);
    if (!audio) {
      audio = document.createElement("audio");
      audio.autoplay = true;
      audio.playsInline = true;
      audio.controls = true;
      audio.dataset.peer = peerId;
      document.getElementById("audios").appendChild(audio);
      audios.set(peerId, audio);
    }
    audio.srcObject = ev.streams[0];
  };

  pc.onconnectionstatechange = () => {
    log("pc state", peerId, pc.connectionState);
    renderPeopleFromState();
  };

  if (localStream) {
    for (const track of localStream.getTracks()) {
      pc.addTrack(track, localStream);
    }
  }

  return pc;
}

async function ensurePC(peerId) {
  if (pcs.has(peerId)) return pcs.get(peerId);
  const pc = makePeerConnection(peerId);
  pcs.set(peerId, pc);
  renderPeopleFromState();
  return pc;
}

async function closePeer(peerId) {
  const pc = pcs.get(peerId);
  if (pc) {
    try { pc.ontrack = null; pc.onicecandidate = null; } catch {}
    try { pc.close(); } catch {}
    pcs.delete(peerId);
  }
  const audio = audios.get(peerId);
  if (audio) {
    try { audio.srcObject = null; } catch {}
    audio.remove();
    audios.delete(peerId);
  }
  remoteMute.delete(peerId);
  renderPeopleFromState();
}

/* Supabase Realtime channel */
async function initCallChannel() {
  if (!authUser) throw new Error("ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­");
  if (!room || !name) throw new Error("å…¥å®¤ã—ã¦ã­");
  if (callChannel) return;

  const uid = myUid();
  callChannel = sb.channel("call-" + room, { config: { presence: { key: uid } } });

  callChannel.on("presence", { event: "sync" }, () => {
    const state = callChannel.presenceState();
    people = new Map();
    for (const key of Object.keys(state)) {
      const metas = state[key] || [];
      const meta = metas[0] || {};
      people.set(key, { name: meta.name || key });
    }
    renderPeopleFromState();
  });

  callChannel.on("presence", { event: "join" }, ({ key, newPresences }) => {
    const meta = (newPresences && newPresences[0]) || {};
    people.set(key, { name: meta.name || key });
    renderPeopleFromState();
  });

  callChannel.on("presence", { event: "leave" }, async ({ key }) => {
    people.delete(key);
    await closePeer(key);
    renderPeopleFromState();
  });

  callChannel.on("broadcast", { event: "signal" }, async ({ payload }) => {
    if (!payload) return;
    const { from, to, data } = payload;
    if (!from || from === myUid()) return;
    if (to && to !== myUid()) return;
    if (!data || !data.kind) return;

    const peerId = from;

    try {
      if (data.kind === "hello") {
        await ensurePC(peerId);

        if (shouldOfferTo(peerId)) {
          const pc = await ensurePC(peerId);
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await sendSignal(peerId, { kind: "offer", sdp: pc.localDescription });
        }
        return;
      }

      if (data.kind === "offer") {
        const pc = await ensurePC(peerId);
        await pc.setRemoteDescription(data.sdp);
        const ans = await pc.createAnswer();
        await pc.setLocalDescription(ans);
        await sendSignal(peerId, { kind: "answer", sdp: pc.localDescription });
        return;
      }

      if (data.kind === "answer") {
        const pc = await ensurePC(peerId);
        await pc.setRemoteDescription(data.sdp);
        renderPeopleFromState();
        return;
      }

      if (data.kind === "ice") {
        const pc = await ensurePC(peerId);
        try { await pc.addIceCandidate(data.candidate); }
        catch (e) { log("addIceCandidate failed", e); }
        return;
      }

      if (data.kind === "hangup") {
        await closePeer(peerId);
        return;
      }

      if (data.kind === "mute") {
        remoteMute.set(peerId, !!data.muted);
        renderPeopleFromState();
        return;
      }
    } catch (e) {
      log("signal error", e);
    }
  });

  await new Promise((resolve, reject) => {
    callChannel.subscribe(async (status) => {
      log("callChannel status:", status);
      if (status === "SUBSCRIBED") {
        try {
          await callChannel.track({ name });
          setCallState("é€šè©±ãƒãƒ£ãƒ³ãƒãƒ«æ¥ç¶šOKï¼ˆå‚åŠ ãƒœã‚¿ãƒ³ã§é€šè©±é–‹å§‹ï¼‰");
          resolve();
        } catch (e) { reject(e); }
      }
      if (status === "CHANNEL_ERROR" || status === "TIMED_OUT") {
        reject(new Error("Realtime subscribe failed: " + status));
      }
    });
  });
}

async function sendSignal(peerId, data) {
  if (!callChannel) return;
  await callChannel.send({
    type: "broadcast",
    event: "signal",
    payload: { from: myUid(), to: peerId, data }
  });
}

async function broadcastHello() {
  if (!callChannel) return;
  await callChannel.send({
    type: "broadcast",
    event: "signal",
    payload: { from: myUid(), to: null, data: { kind: "hello" } }
  });
}
async function broadcastMute() {
  if (!callChannel) return;
  await callChannel.send({
    type: "broadcast",
    event: "signal",
    payload: { from: myUid(), to: null, data: { kind: "mute", muted: micMuted } }
  });
}

/* é€šè©±å‚åŠ ï¼ˆé–‹å§‹ï¼‰ */
async function startVoice() {
  if (!authUser) return alert("å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­ï¼");
  if (!room || !name) return alert("å…ˆã«å…¥å®¤ã—ã¦ã­ï¼");

  try {
    await initCallChannel();

    if (!localStream) {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      micMuted = false;
      updateMuteBtn();
      log("mic ok");
    }

    inCall = true;

    await upsertCallParticipant();
    startHeartbeat();
    await refreshActiveCallRooms();

    setButtonsState();
    await loadRooms();

    await new Promise(r => setTimeout(r, 200));

    const state = callChannel.presenceState();
    const keys = Object.keys(state).filter(k => k !== myUid());
    for (const pid of keys) await ensurePC(pid);

    await broadcastHello();
    await broadcastMute();

    setCallState("é€šè©±å‚åŠ ä¸­ï¼ˆæ¥ç¶šé–‹å§‹â€¦ï¼‰");
    renderPeopleFromState();
  } catch (e) {
    log("startVoice error", e);
    alert("é€šè©±é–‹å§‹å¤±æ•—: " + (e?.message || e));
  }
}

/* ãƒŸãƒ¥ãƒ¼ãƒˆ */
async function toggleMute() {
  if (!localStream) {
    alert("å…ˆã«ã€é€šè©±ã«å‚åŠ ï¼ˆé–‹å§‹ï¼‰ã€ã‚’æŠ¼ã—ã¦ãƒã‚¤ã‚¯ã‚’å–ã£ã¦ã­ï¼");
    return;
  }
  micMuted = !micMuted;
  for (const t of localStream.getAudioTracks()) t.enabled = !micMuted;
  updateMuteBtn();
  await broadcastMute();
  renderPeopleFromState();
}

/* é€šè©±é€€å‡º */
async function hangupAll() {
  if (!authUser) return;

  if (!inCall && !callChannel && !localStream) {
    await refreshActiveCallRooms();
    setButtonsState();
    return;
  }

  // â˜…å…ˆã«DBã‹ã‚‰æ¶ˆã™ï¼ˆä»–äººã®ğŸ“ãŒæ—©ãæ¶ˆãˆã‚‹ï¼‰
  await safeCallLeave("hangupAll");

  if (callChannel) {
    try {
      await callChannel.send({
        type: "broadcast",
        event: "signal",
        payload: { from: myUid(), to: null, data: { kind: "hangup" } }
      });
    } catch {}
  }

  for (const pid of Array.from(pcs.keys())) await closePeer(pid);

  if (localStream) {
    try { localStream.getTracks().forEach(t => t.stop()); } catch {}
    localStream = null;
  }

  micMuted = false;
  updateMuteBtn();

  if (callChannel) {
    try { await callChannel.untrack(); } catch {}
    try { await sb.removeChannel(callChannel); } catch {}
    callChannel = null;
  }

  people = new Map();
  remoteMute.clear();
  renderPeople([]);

  inCall = false;

  await refreshActiveCallRooms();
  setButtonsState();
  await loadRooms();

  setCallState("é€šè©±é€€å‡ºï¼ˆæœªæ¥ç¶šï¼‰");
}

/* ã‚¿ãƒ–é–‰ã˜/æ›´æ–°/ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã‚‚DBè§£é™¤ */
window.addEventListener("pagehide", () => safeCallLeave("pagehide"));
window.addEventListener("beforeunload", () => safeCallLeave("beforeunload"));
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "hidden") safeCallLeave("visibilitychange:hidden");
});
window.addEventListener("freeze", () => safeCallLeave("freeze"));

/* èµ·å‹•æ™‚ */
(async () => {
  await reloadSession();
  setButtonsState();

  if (authUser) {
    await loadRooms();
    await startRealtime();
  } else {
    document.getElementById("roomsBox").innerHTML = "<div>ğŸ” ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã­</div>";
  }

  updateMuteBtn();
  setCallState("æœªæ¥ç¶šï¼ˆå…¥å®¤ã—ã¦ã‹ã‚‰ä½¿ã£ã¦ã­ï¼‰");

  // â˜…é€šè©±ã—ã¦ãªã„äººå´ã§ã‚‚ğŸ“ãŒæ¶ˆãˆã‚‹ã‚ˆã†ã«å®šæœŸæ›´æ–°
  setInterval(async () => {
    if (!authUser) return;
    await refreshActiveCallRooms();
    await loadRooms();
  }, 8000);

  // ã‚»ãƒƒã‚·ãƒ§ãƒ³å¤‰åŒ–è¿½å¾“
  sb.auth.onAuthStateChange(async () => {
    await reloadSession();
    setButtonsState();
    if (authUser) {
      await loadRooms();
      await startRealtime();
    }
  });

  log("ready. authUser=", authUser?.id || null);
})();
</script>
</body>
</html>

